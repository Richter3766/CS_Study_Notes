# 페이징(Paging)

페이징은 현대 운영체제에서 메모리를 효율적으로 관리하기 위한 핵심적인 기법입니다.  
이전의 메모리 관리 방식인 base/bound register나 segmentation 방식과는 달리, 페이징은 가상 메모리와 물리 메모리를 **고정된 크기의 블록**으로 나누어 관리한다는 특징을 가집니다.  
여기서 나뉜 각각의 블록을 **페이지**라고 부릅니다.

페이징의 가장 중요한 역할은 **가상 주소를 물리 주소로 변환**하는 것입니다.  
프로그램은 가상 주소를 사용해 메모리에 접근하지만, 실제 데이터는 물리 메모리에 저장되어 있습니다.  
따라서 가상 주소를 물리 주소로 변환하는 과정이 반드시 필요하며, 이 변환 과정을 효율적으로 관리하기 위해 페이지 테이블과 TLB라는 핵심적인 요소들이 사용됩니다.

## 핵심 요소 1: 페이지 테이블 (Page Table)

페이지 테이블은 가상 주소와 물리 주소 간의 변환을 담당하는 핵심적인 자료구조입니다.

### 페이지 테이블의 역할

**페이지 테이블**은 가상 주소 공간의 각 페이지(VPN, Virtual Page Number)와 물리 주소 공간의 페이지(PPN, Physical Page Number) 간의 매핑 정보를 저장합니다.  
이를 통해 운영체제는 프로그램이 사용하는 가상 주소를 실제 물리 메모리 주소로 변환할 수 있습니다.

### 페이지 테이블 항목 (PTE, Page Table Entry)

페이지 테이블은 단순한 VPN-PPN 매핑 정보 외에도 해당 페이지에 대한 다양한 **메타데이터**를 함께 저장할 수 있습니다.  
이러한 정보를 담고 있는 각 항목을 PTE (Page Table Entry)라고 합니다.  
PTE에는 다음과 같은 정보가 포함될 수 있습니다.

- **접근 권한 (Access Rights):**  
  페이지에 대한 읽기, 쓰기, 실행 권한을 지정합니다.
- **유효 비트 (Valid Bit):**  
  페이지가 현재 물리 메모리에 존재하는지 여부를 나타냅니다.
- **수정 비트 (Dirty Bit):**  
  페이지가 수정되었는지 여부를 나타냅니다. 쓰기 작업이 발생하면 설정됩니다.

### 페이지 테이블의 크기 문제와 해결 방법

하지만 페이지 테이블은 그 크기가 매우 커질 수 있다는 단점이 있습니다.  
가상 주소 공간이 클수록 더 많은 페이지를 관리해야 하므로 페이지 테이블의 크기도 함께 증가합니다.  
이러한 문제를 해결하기 위해 **다단계(Multi level) 페이지 테이블**이나 **역(Inverted) 페이지 테이블**과 같은 기법들이 사용됩니다.

## 핵심 요소 2: TLB (Translation Lookaside Buffer)

TLB는 페이지 테이블 접근 속도를 향상시키기 위한 캐시입니다.

### TLB의 필요성

페이지 테이블은 메모리에 저장되어 있기 때문에, 매번 메모리 접근을 할 때마다 페이지 테이블을 먼저 참조해야 한다는 단점이 있습니다.  
이는 CPU가 데이터를 가져오기 위해 메모리에 두 번 접근해야 함을 의미하며, 메모리 접근 속도가 CPU에 비해 훨씬 느리기 때문에 전체적인 시스템 성능에 큰 영향을 미칩니다.

### TLB의 역할 및 동작 방식

이러한 성능 저하를 해결하기 위해 도입된 것이 **TLB**(Translation Lookaside Buffer)입니다. TLB는 페이지 테이블의 캐시 역할을 수행하며, 최근에 사용된 VPN-PPN 매핑 정보를 저장하여 주소 변환 속도를 획기적으로 향상시킵니다.

TLB의 동작 방식은 다음과 같습니다.

1.  CPU가 가상 주소를 요청하면 MMU (Memory Management Unit)는 먼저 TLB를 검색합니다.
2.  **TLB Hit:** TLB에 해당 VPN에 대한 정보가 있으면, 해당 PPN을 사용하여 빠르게 물리 주소를 얻습니다.
3.  **TLB Miss:** TLB에 해당 정보가 없으면, 페이지 테이블에 접근하여 VPN에 해당하는 PPN을 찾습니다.
4.  찾은 PPN을 사용하여 물리 주소를 얻고, 이후 빠른 접근을 위해 TLB에 해당 VPN-PPN 매핑 정보를 추가합니다.
5.  이후 동일한 VPN에 대한 접근은 TLB hit를 통해 빠르게 처리됩니다.

### TLB와 지역성 (Locality)

TLB는 캐시의 지역성(locality) 원리를 활용합니다.  
프로그램은 특정 메모리 영역에 집중적으로 접근하는 경향이 있으므로, TLB에 저장된 정보가 재사용될 가능성이 높습니다.

### TLB Miss 처리 및 페이지 교체 알고리즘

TLB miss가 발생했을 때는 어떤 엔트리를 교체할지 결정하는 **페이지 교체 알고리즘** (LRU, FIFO 등)이 사용됩니다.

### TLB Miss 처리 방식: 하드웨어 vs 소프트웨어

TLB miss 처리 방식은 **하드웨어** 또는 **소프트웨어**에서 관리할 수 있습니다.  
하드웨어 방식은 빠르지만 복잡하고, 소프트웨어 방식은 유연하지만 오버헤드가 발생할 수 있습니다.

### 컨텍스트 스위칭과 TLB 관리: 플러시(Flush) vs ASID

**컨텍스트 스위칭**은 CPU가 실행하는 프로세스를 변경하는 작업입니다.  
각 프로세스는 자신만의 페이지 테이블을 가지고 있기 때문에, 컨텍스트 스위칭 시 TLB에 저장된 이전 프로세스의 정보를 제거하고 새로운 프로세스의 정보를 로드해야 합니다.  
이를 위해 다음과 같은 두 가지 방법이 사용될 수 있습니다.

- **TLB 플러시 (Flush):**
  - TLB의 모든 엔트리를 무효화하는 방법입니다.
  - 간단하지만, TLB에 저장된 유효한 정보까지 모두 제거하므로 성능 저하를 초래할 수 있습니다.
- **ASID (Address Space Identifier):**
  - 각 프로세스에 고유한 ASID를 부여하고, TLB 엔트리에 ASID를 함께 저장하는 방법입니다.
  - 컨텍스트 스위칭 시 TLB를 플러시하는 대신, 현재 실행 중인 프로세스의 ASID와 일치하는 엔트리만 사용합니다.
  - ASID를 사용하면 TLB 플러시의 오버헤드를 줄일 수 있지만, TLB의 복잡도가 증가합니다.

## 페이징의 장점과 한계

페이징은 메모리 관리를 효율적으로 수행할 수 있도록 다양한 장점을 제공하지만, 몇 가지 한계점도 가지고 있습니다.

### 장점

- **외부 단편화 해결:**  
  페이지를 고정된 크기로 나누어 사용하므로, 메모리 공간이 작은 조각으로 나뉘는 외부 단편화 문제를 해결할 수 있습니다.
- **가상 메모리 구현 용이:**  
  페이지 단위로 메모리를 관리하므로, 실제 물리 메모리보다 더 큰 가상 메모리 공간을 사용할 수 있습니다.
- **메모리 보호 기능 강화:**  
  페이지 테이블을 통해 각 페이지에 대한 접근 권한을 설정하여 메모리 보호 기능을 강화할 수 있습니다.

### 한계

- **내부 단편화 발생 가능성:**  
  페이지 크기보다 작은 데이터를 저장할 경우, 페이지 내부에 남는 공간이 발생하여 내부 단편화가 발생할 수 있습니다.
- **페이지 테이블 오버헤드:**  
  페이지 테이블의 크기가 커질 수 있으며, 페이지 테이블 접근에 따른 오버헤드가 발생할 수 있습니다.
