# 스케줄링(Scheduling)

스케줄링(Scheduling)은 운영 체제(OS)에서 CPU가 어떤 작업을 수행할지를 결정하는 중요한 과정입니다.  
CPU 자원을 효과적으로 관리하기 위해 다양한 스케줄링 알고리즘이 사용됩니다.

## 주요 스케줄링 매트릭스

### 1. Turnaround Time (총 처리 시간):

프로세스가 제출된 시점부터 완료되는 시점까지 걸리는 총 시간입니다.  
 즉, 프로세스의 대기 시간, 실행 시간, 입출력 시간 등을 모두 포함합니다.

### 2. Fairness (공정성):

모든 프로세스가 공정하게 CPU 자원을 할당받는 정도를 나타냅니다.  
 특정 프로세스가 과도하게 자원을 점유하지 않도록 보장하는 것이 중요합니다.

### 3. Response Time (응답 시간):

사용자가 프로세스를 시작한 시점부터 첫 번째 응답이 돌아오는 시점까지 걸리는 시간입니다.  
인터랙티브 시스템에서 특히 중요한 요소입니다.

## 스케줄링 알고리즘 종류

이제 각 알고리즘의 특징과 장단점을 살펴보겠습니다.

### FIFO (First In First Out)

- **설명**:  
  가장 먼저 도착한 프로세스가 가장 먼저 CPU를 할당받는 방식입니다.  
  단순한 큐 구조를 기반으로 하여 순차적으로 처리합니다.

- **장점**:  
  구현이 간단하고 직관적이며, 프로세스의 순서를 유지합니다.

- **단점**:  
  Convoy Effect가 발생할 수 있습니다.  
  긴 작업이 CPU를 점유하면 짧은 작업이 대기하게 되어 평균 Turnaround Time과 Response Time이 악화됩니다.  
  공정성 측면에서도 긴 대기 시간을 초래할 수 있습니다.

### SJF (Shortest Job First)

- **설명**:  
  가장 짧은 작업을 우선적으로 처리하는 방식입니다. 모든 작업이 동시에 도착할 경우 최적의 성능을 보장합니다.

- **장점**:  
  평균 대기 시간이 가장 짧아지는 경향이 있으며, Turnaround Time도 줄어듭니다.

- **단점**:  
  작업이 동시에 도착하지 않을 경우 Convoy Effect가 발생할 수 있습니다.  
  또한, 낮은 우선순위의 작업이 장시간 대기할 수 있어 공정성이 저하될 수 있습니다.

### STCF (Shortest Time to Completion First)

- **설명**:  
  남은 실행 시간이 가장 짧은 작업을 우선적으로 처리합니다.

- **장점**:  
  짧은 작업이 우선 처리되어 대기 시간이 줄어드므로 평균 Turnaround Time이 개선될 수 있습니다.

- **단점**:  
  보통 작업의 완료 시간을 예측하기 어려워 적용이 어렵습니다.  
  상대적으로 긴 작업은 대기하게 되어 Response Time이 나빠질 수 있습니다.  
  공정성도 저해될 수 있습니다.

### Round Robin

- **설명**:  
  각 프로세스에 고정된 타임 슬라이스를 할당하여 순환적으로 CPU를 사용하는 방식입니다.

- **장점**:  
  뛰어난 Response Time을 보장하며, 공정성을 제공합니다.  
  모든 프로세스가 일정하게 CPU를 할당받기 때문에 Starvation이 발생하지 않습니다.

- **단점**:  
  타임 슬라이스의 길이가 중요합니다.  
  너무 짧으면 컨텍스트 스위치 비용이 커지고, 너무 길면 CPU 자원의 낭비가 발생할 수 있어 평균 Turnaround Time이 증가할 수 있습니다.

### Priority Scheduling

- **설명**:  
  각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스가 먼저 실행됩니다.

- **장점**:  
  중요한 작업을 신속하게 처리할 수 있으며, 평균 Turnaround Time을 줄일 수 있습니다.

- **단점**:  
  낮은 우선순위의 작업이 대기하는 Starvation 문제가 발생할 수 있으며, 공정성이 저하될 수 있습니다.

### Multilevel Queue Scheduling

- **설명**:  
  여러 개의 대기열을 두고, 각 대기열에 서로 다른 스케줄링 알고리즘을 적용합니다.

- **장점**:  
  다양한 유형의 작업을 효율적으로 처리할 수 있으며, 각 대기열에 적합한 알고리즘을 적용하여 Turnaround Time과 Response Time을 최적화할 수 있습니다.

- **단점**:  
  각 대기열 간의 관리가 복잡할 수 있으며, 특정 대기열에 과도한 자원이 할당될 경우 다른 대기열의 작업이 지연될 수 있어 공정성이 저하될 수 있습니다.

### Lottery Scheduling

- **설명**:  
  각 프로세스에 티켓을 할당하고, CPU 시간을 할당할 프로세스를 무작위로 선택합니다.  
  프로세스가 수행될 때마다 티켓을 다시 할당받을 수 있습니다.

- **장점**:  
  공정성을 보장하면서도 간단하게 구현할 수 있으며, 다양한 우선순위를 가진 작업을 유연하게 처리할 수 있습니다.  
  또한, 우선순위가 높은 작업이 더 많은 티켓을 가지므로 자원 배분이 자연스럽게 이루어집니다.

- **단점**:  
  무작위성으로 인해 예측할 수 없는 대기 시간이 발생할 수 있습니다.  
  낮은 우선순위의 프로세스가 오랜 시간 동안 CPU 시간을 받지 못할 위험이 있습니다.  
  티켓 관리와 같은 추가적인 오버헤드가 발생할 수 있습니다.

### Stride Scheduling

- **설명**:  
  각 프로세스에 'stride' 값을 할당하여 CPU 시간을 할당합니다. 프로세스가 CPU 시간을 요청할 때마다 stride 값이 증가하고, 가장 낮은 stride 값을 가진 프로세스가 CPU를 할당받습니다.

- **장점**:  
  공정성을 유지하면서도 각 프로세스의 우선순위를 효과적으로 반영할 수 있습니다. 일정한 시간 간격으로 자원을 재분배하여 모든 프로세스가 공정하게 CPU 시간을 받을 수 있도록 합니다.

- **단점**:  
  구현이 복잡할 수 있으며, stride 값의 계산과 관리가 필요합니다. 또한, 대기열의 크기가 커질 경우 성능 저하가 발생할 수 있습니다.

### CFS(Completely Fair Scheduling)

- **설명**:  
  모든 프로세스에 대해 CPU 시간을 공정하게 분배하는 스케줄링 알고리즘입니다.  
  각 프로세스가 CPU를 사용할 수 있는 가상 실행 시간(vruntime)을 기반으로 합니다. 프로세스의 가상 시간이 가장 적은 프로세스가 CPU를 할당받습니다.

- **장점**:  
  CPU 시간을 공평하게 분배하여 모든 프로세스가 평등하게 자원을 받을 수 있습니다.  
  또한, 대화형 작업에 적합하여 응답 시간이 짧습니다.

- **단점**:  
  구현이 복잡할 수 있으며, 많은 수의 프로세스가 있을 경우 관리 오버헤드가 증가할 수 있습니다.  
  특정 작업이 지나치게 많은 CPU 시간을 요구할 경우, 다른 작업의 대기 시간이 길어질 수 있습니다.
