# 트랩(Trap)

### 필요성

사용자 프로세스가 CPU나 메모리와 같은 자원에 자유롭게 접근할 수 있다면, 여러 가지 문제가 발생할 수 있습니다.  
자원을 점유하여 다른 프로세스의 동작을 방해하거나, 예기치 않은 오류를 발생시킬 수 있으며, 이는 결국 시스템의 안정성을 저해하게 됩니다.

이를 방지하기 위해 운영체제(OS)는 리소스에 대한 제한된 접근을 허용하는 **사용자 모드**(user mode)와 모든 접근이 허용되는 **커널 모드**(kernel mode)를 구분합니다.

### 시스템 콜(System Call)

사용자 프로세스가 리소스에 직접 접근해야 할 필요가 있을 경우, **시스템 콜**(system call)이 사용됩니다.  
시스템 콜은 하드웨어에서 인터럽트를 발생시키는 것과 유사하게, 프로세스가 **트랩**(trap)을 발생시켜 커널에 요청을 전달합니다.  
이후 커널은 요청을 처리하고, 작업이 끝난 후에는 **return from trap instruction**(RIET)를 통해 사용자 모드로 돌아가 사용자 프로세스의 실행을 계속 진행합니다.

### 트랩 핸들링(Trap Handling)

트랩 발생 시 하드웨어는 이를 신중하게 처리해야 합니다.

- **레지스터 저장**:  
  트랩을 발생시킨 프로세스의 레지스터 상태를 저장하여, RIET 시 원래의 동작 지점으로 돌아갈 수 있도록 해야 합니다.
- **x86 아키텍처**:  
  x86에서는 CPU가 프로그램 카운터(PC), 플래그, 일부 레지스터를 커널 스택에 저장합니다.

운영체제가 발생한 트랩의 종류와 동작을 인식할 수 있도록 **트랩 테이블**(trap table)이 존재합니다.  
이 테이블은 부팅 시 초기화되며, CPU가 각 트랩 핸들러의 위치를 알 수 있도록 합니다.

이와 같은 시스템 콜 지원을 통해 운영체제는 사용자 프로세스가 커널 영역에 직접적으로 접근하는 것을 방지하고, 필요한 작업을 간접적으로 수행하도록 합니다.  
이를 위해 OS는 사용자 프로세스의 메모리 영역 일부에 위치하게 되어, 안정적이고 안전한 시스템 운영을 도모합니다.

### 트랩 핸들링 과정

1. 시스템 콜 요청:  
   사용자 프로세스가 필요한 작업을 수행하기 위해 시스템 콜을 요청합니다.

2. 트랩 발생:  
   시스템 콜 요청이 발생하면, 프로세스는 트랩(trap)을 발생시킵니다.

3. 컨텍스트 저장:  
   트랩이 발생하면 CPU는 현재 프로세스의 상태(레지스터, 프로그램 카운터 등)를 저장합니다.

4. 커널 모드 진입:  
   커널이 트랩을 처리하기 위해 커널 모드로 전환됩니다. CPU는 트랩 테이블을 참조하여 해당 트랩에 맞는 핸들러를 찾습니다.

5. 트랩 핸들러 실행:  
   커널은 트랩 핸들러를 실행하여 요청된 작업을 처리합니다.

6. 결과 반환 및 상태 복원:  
   작업이 완료되면, 커널은 결과를 사용자 프로세스에 반환하고, 저장된 컨텍스트를 복원합니다.

7. 사용자 모드로 복귀:  
   return from trap instruction (RIET)를 통해 프로세스는 사용자 모드로 돌아갑니다.

8. 프로세스 실행 계속:  
   사용자 모드로 복귀한 후, 프로세스는 이전 상태에서 계속 실행을 진행합니다.

### 생각해보기

1. 시스템 콜 요청으로 핸들링하는 중에 타이머 인터럽트(Timer Interrupt)가 발생한다면 어떤 일이 일어날까?
2. 한 이터럽트를 처리 중일 때 또 다른 인터럽트가 일어난다면 OS는 어떻게 핸들링할까?
