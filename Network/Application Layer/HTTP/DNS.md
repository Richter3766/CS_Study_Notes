# DNS (Domain Name System)

DNS는 IP 주소와 도메인 이름을 매칭하여 주는 시스템입니다.  
사람들은 숫자 형태의 IP 주소를 기억하기 어려우므로, DNS는 더 친숙한 도메인 이름을 사용하여 인터넷 리소스에 접근하게 합니다.

많은 네임 서버들이 분산되어 구현되어 있어, DNS는 단일 실패 지점(SPOF) 없이 운영됩니다.

## DNS 서비스

- **호스트 이름을 IP 주소로 변환**:  
  사용자가 입력한 도메인 이름을 IP 주소로 변환하여 웹사이트에 접근할 수 있게 합니다.
- **호스트 별칭**:  
  CNAME 레코드를 이용해 여러 도메인 이름이 동일한 IP 주소를 가리킬 수 있도록 합니다.
- **메일 서버 별칭**:  
  MX 레코드를 통해 이메일 서버를 지정하여, 이메일 전달을 가능하게 합니다.
- **로드 분산**:  
  여러 서버에 트래픽을 분산시켜 성능을 향상시킬 수 있습니다.

## DNS가 중앙화가 아닌 이유

- **단일 실패 지점(SPOF)의 위험성**:  
  중앙 집중식 시스템은 특정 서버의 장애로 전체 서비스가 중단될 수 있습니다.
- **트래픽 규모**:  
  전 세계적으로 분산된 사용자들이 동시에 요청을 하기 때문에, 중앙 집중식 모델이 아닌 분산 모델이 필요합니다.
- **지리적 거리**:  
  사용자와 서버 간의 거리가 멀어질 경우, 응답 시간이 지연될 수 있습니다.
- **유지보수성**:  
  분산된 시스템은 각 서버의 유지보수가 용이하고, 서버를 추가하는 것이 용이합니다.

## DNS 구조

- **TLD (Top Level Domain) 서버**:  
  최상위 도메인(.com, .org 등)을 관리하는 서버입니다.
- **Authoritative DNS Servers**:  
  특정 도메인에 대한 DNS 정보를 저장하고 제공하는 서버입니다.
- **Local DNS name Servers**:  
  사용자의 요청을 처리하고, 캐시된 정보를 통해 빠르게 응답하는 서버입니다.

## DNS 쿼리 과정

### 반복 쿼리 (Iterative Query)

1. 클라이언트가 특정 도메인을 루트 서버에 요청합니다.
2. 루트 서버는 클라이언트에게 다음 단계의 DNS 서버 주소를 반환합니다.
3. 클라이언트는 해당 DNS 서버에 쿼리를 보내고, IP 주소를 받습니다.

### 재귀 쿼리 (Recursive Query)

1. 클라이언트가 로컬 DNS 서버에 도메인 이름을 요청합니다.
2. 로컬 DNS 서버가 필요한 정보를 찾기 위해 다른 DNS 서버에 쿼리를 보냅니다.
3. 요청한 IP 주소를 찾으면 이를 클라이언트에게 반환합니다.

## DNS 레코드의 캐싱과 업데이트

DNS 레코드는 성능 향상을 위해 캐시되지만, 오래된 정보는 문제를 일으킬 수 있습니다.  
이를 관리하기 위해 DNS 서버는 TTL(Time To Live) 값을 사용합니다.

### 캐싱 작동 방식

- **TTL 설정**:  
  각 레코드는 TTL 값을 가지며, 이 시간이 지나면 최신 정보를 요청해야 합니다.
- **로컬 네임 서버**:  
  TLD 서버의 정보는 로컬 네임 서버에 캐시되어, 루트 서버에 자주 접근할 필요가 줄어듭니다.

## DNS 레코드 형식

- **A**: IPv4 주소를 지정합니다.
- **AAAA**: IPv6 주소를 지정합니다.
- **NS**: 네임 서버를 지정합니다.
- **CNAME**: 별칭을 지정하여 다른 도메인 이름을 가리킵니다.
- **MX**: 메일 서버를 지정합니다.

## DNS에 레코드 넣기

DNS 레코드는 일반적으로 DNS 관리 도구나 API를 통해 추가하거나 수정할 수 있습니다.  
이 과정에서 권한 있는 DNS 서버에서 직접 작업해야 합니다.

## DNS 보안

DNS는 다음과 같은 보안 위협에 직면할 수 있습니다:

- **DDoS 공격**:  
  대량의 트래픽을 발생시켜 서비스를 마비시킵니다.
- **리디렉션 공격**:  
  사용자를 악의적인 사이트로 유도합니다.

### 해결 방법

- **DNSSEC**:  
  DNS 데이터의 무결성을 검증하고 보안을 강화하는 기술입니다.
